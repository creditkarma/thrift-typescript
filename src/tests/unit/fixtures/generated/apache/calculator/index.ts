/* tslint:disable */
/*
 * Autogenerated by @creditkarma/thrift-typescript v{{VERSION}}
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
*/
import Int64 = require("node-int64");
import * as thrift from "test-lib";
import * as shared from "./../shared";
import * as common from "./../common";
import * as operation from "./../operation";
export type MyInteger = number;
export import Operation = operation.Operation;
export import CommonStruct = common.CommonStruct;
export const INT32CONSTANT: number = 9853;
export const MAPCONSTANT: Map<string, string> = new Map([["hello", "world"], ["goodnight", "moon"]]);
export interface IWorkArgs {
    num1: number;
    num2: number;
    op: Operation;
    comment?: string;
}
export class Work {
    public num1: number = 0;
    public num2: number;
    public op: Operation;
    public comment?: string;
    constructor(args: IWorkArgs) {
        if (args != null && args.num1 != null) {
            this.num1 = args.num1;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num1] is unset!");
        }
        if (args != null && args.num2 != null) {
            this.num2 = args.num2;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num2] is unset!");
        }
        if (args != null && args.op != null) {
            this.op = args.op;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[op] is unset!");
        }
        if (args != null && args.comment != null) {
            this.comment = args.comment;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("Work");
        if (this.num1 != null) {
            output.writeFieldBegin("num1", thrift.Thrift.Type.I32, 1);
            output.writeI32(this.num1);
            output.writeFieldEnd();
        }
        if (this.num2 != null) {
            output.writeFieldBegin("num2", thrift.Thrift.Type.I32, 2);
            output.writeI32(this.num2);
            output.writeFieldEnd();
        }
        if (this.op != null) {
            output.writeFieldBegin("op", thrift.Thrift.Type.I32, 3);
            output.writeI32(this.op);
            output.writeFieldEnd();
        }
        if (this.comment != null) {
            output.writeFieldBegin("comment", thrift.Thrift.Type.STRING, 4);
            output.writeString(this.comment);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): Work {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_1: number = input.readI32();
                        _args.num1 = value_1;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_2: number = input.readI32();
                        _args.num2 = value_2;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 3:
                    if (fieldType === thrift.Thrift.Type.I32) {
                        const value_3: Operation = input.readI32();
                        _args.op = value_3;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 4:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_4: string = input.readString();
                        _args.comment = value_4;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_args.num1 !== undefined && _args.num2 !== undefined && _args.op !== undefined) {
            return new Work(_args);
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read Work from input");
        }
    }
}
export interface IFirstNameArgs {
    name?: string;
}
export class FirstName {
    public name?: string;
    constructor(args?: IFirstNameArgs) {
        if (args != null && args.name != null) {
            this.name = args.name;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("FirstName");
        if (this.name != null) {
            output.writeFieldBegin("name", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.name);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): FirstName {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_5: string = input.readString();
                        _args.name = value_5;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new FirstName(_args);
    }
}
export interface ILastNameArgs {
    name?: string;
}
export class LastName {
    public name?: string;
    constructor(args?: ILastNameArgs) {
        if (args != null && args.name != null) {
            this.name = args.name;
        }
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("LastName");
        if (this.name != null) {
            output.writeFieldBegin("name", thrift.Thrift.Type.STRING, 1);
            output.writeString(this.name);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): LastName {
        input.readStructBegin();
        let _args: any = {};
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRING) {
                        const value_6: string = input.readString();
                        _args.name = value_6;
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        return new LastName(_args);
    }
}
export interface IChoiceArgs {
    firstName?: FirstName;
    lastName?: LastName;
}
export class Choice {
    public firstName?: FirstName;
    public lastName?: LastName;
    constructor(args?: IChoiceArgs) {
        let _fieldsSet: number = 0;
        if (args != null) {
            if (args.firstName != null) {
                _fieldsSet++;
                this.firstName = args.firstName;
            }
            if (args.lastName != null) {
                _fieldsSet++;
                this.lastName = args.lastName;
            }
            if (_fieldsSet > 1) {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.INVALID_DATA, "Cannot read a TUnion with more than one set value!");
            }
            else if (_fieldsSet < 1) {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.INVALID_DATA, "Cannot read a TUnion with no set value!");
            }
        }
    }
    public static fromFirstName(firstName: FirstName): Choice {
        return new Choice({ firstName });
    }
    public static fromLastName(lastName: LastName): Choice {
        return new Choice({ lastName });
    }
    public write(output: thrift.TProtocol): void {
        output.writeStructBegin("Choice");
        if (this.firstName != null) {
            output.writeFieldBegin("firstName", thrift.Thrift.Type.STRUCT, 1);
            this.firstName.write(output);
            output.writeFieldEnd();
        }
        if (this.lastName != null) {
            output.writeFieldBegin("lastName", thrift.Thrift.Type.STRUCT, 2);
            this.lastName.write(output);
            output.writeFieldEnd();
        }
        output.writeFieldStop();
        output.writeStructEnd();
        return;
    }
    public static read(input: thrift.TProtocol): Choice {
        let _fieldsSet: number = 0;
        let _returnValue: Choice | null = null;
        input.readStructBegin();
        while (true) {
            const ret: thrift.TField = input.readFieldBegin();
            const fieldType: thrift.Thrift.Type = ret.ftype;
            const fieldId: number = ret.fid;
            if (fieldType === thrift.Thrift.Type.STOP) {
                break;
            }
            switch (fieldId) {
                case 1:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        _fieldsSet++;
                        const value_7: FirstName = FirstName.read(input);
                        _returnValue = Choice.fromFirstName(value_7);
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                case 2:
                    if (fieldType === thrift.Thrift.Type.STRUCT) {
                        _fieldsSet++;
                        const value_8: LastName = LastName.read(input);
                        _returnValue = Choice.fromLastName(value_8);
                    }
                    else {
                        input.skip(fieldType);
                    }
                    break;
                default: {
                    input.skip(fieldType);
                }
            }
            input.readFieldEnd();
        }
        input.readStructEnd();
        if (_fieldsSet > 1) {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.INVALID_DATA, "Cannot read a TUnion with more than one set value!");
        }
        else if (_fieldsSet < 1) {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.INVALID_DATA, "Cannot read a TUnion with no set value!");
        }
        if (_returnValue !== null) {
            return _returnValue;
        }
        else {
            throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read data for TUnion");
        }
    }
}
export namespace Calculator {
    export interface IPingArgsArgs {
    }
    export class PingArgs {
        constructor() {
        }
        public write(output: thrift.TProtocol): void {
            output.writeStructBegin("PingArgs");
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        }
        public static read(input: thrift.TProtocol): PingArgs {
            input.readStructBegin();
            while (true) {
                const ret: thrift.TField = input.readFieldBegin();
                const fieldType: thrift.Thrift.Type = ret.ftype;
                const fieldId: number = ret.fid;
                if (fieldType === thrift.Thrift.Type.STOP) {
                    break;
                }
                switch (fieldId) {
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return new PingArgs();
        }
    }
    export interface IAddArgsArgs {
        num1: number;
        num2: number;
    }
    export class AddArgs {
        public num1: number;
        public num2: number;
        constructor(args: IAddArgsArgs) {
            if (args != null && args.num1 != null) {
                this.num1 = args.num1;
            }
            else {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num1] is unset!");
            }
            if (args != null && args.num2 != null) {
                this.num2 = args.num2;
            }
            else {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num2] is unset!");
            }
        }
        public write(output: thrift.TProtocol): void {
            output.writeStructBegin("AddArgs");
            if (this.num1 != null) {
                output.writeFieldBegin("num1", thrift.Thrift.Type.I32, 1);
                output.writeI32(this.num1);
                output.writeFieldEnd();
            }
            if (this.num2 != null) {
                output.writeFieldBegin("num2", thrift.Thrift.Type.I32, 2);
                output.writeI32(this.num2);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        }
        public static read(input: thrift.TProtocol): AddArgs {
            input.readStructBegin();
            let _args: any = {};
            while (true) {
                const ret: thrift.TField = input.readFieldBegin();
                const fieldType: thrift.Thrift.Type = ret.ftype;
                const fieldId: number = ret.fid;
                if (fieldType === thrift.Thrift.Type.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 1:
                        if (fieldType === thrift.Thrift.Type.I32) {
                            const value_9: number = input.readI32();
                            _args.num1 = value_9;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    case 2:
                        if (fieldType === thrift.Thrift.Type.I32) {
                            const value_10: number = input.readI32();
                            _args.num2 = value_10;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            if (_args.num1 !== undefined && _args.num2 !== undefined) {
                return new AddArgs(_args);
            }
            else {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AddArgs from input");
            }
        }
    }
    export interface IAddInt64ArgsArgs {
        num1: number | Int64;
        num2: number | Int64;
    }
    export class AddInt64Args {
        public num1: Int64;
        public num2: Int64;
        constructor(args: IAddInt64ArgsArgs) {
            if (args != null && args.num1 != null) {
                if (typeof args.num1 === "number") {
                    this.num1 = new Int64(args.num1);
                }
                else {
                    this.num1 = args.num1;
                }
            }
            else {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num1] is unset!");
            }
            if (args != null && args.num2 != null) {
                if (typeof args.num2 === "number") {
                    this.num2 = new Int64(args.num2);
                }
                else {
                    this.num2 = args.num2;
                }
            }
            else {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num2] is unset!");
            }
        }
        public write(output: thrift.TProtocol): void {
            output.writeStructBegin("AddInt64Args");
            if (this.num1 != null) {
                output.writeFieldBegin("num1", thrift.Thrift.Type.I64, 1);
                output.writeI64(this.num1);
                output.writeFieldEnd();
            }
            if (this.num2 != null) {
                output.writeFieldBegin("num2", thrift.Thrift.Type.I64, 2);
                output.writeI64(this.num2);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        }
        public static read(input: thrift.TProtocol): AddInt64Args {
            input.readStructBegin();
            let _args: any = {};
            while (true) {
                const ret: thrift.TField = input.readFieldBegin();
                const fieldType: thrift.Thrift.Type = ret.ftype;
                const fieldId: number = ret.fid;
                if (fieldType === thrift.Thrift.Type.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 1:
                        if (fieldType === thrift.Thrift.Type.I64) {
                            const value_11: Int64 = input.readI64();
                            _args.num1 = value_11;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    case 2:
                        if (fieldType === thrift.Thrift.Type.I64) {
                            const value_12: Int64 = input.readI64();
                            _args.num2 = value_12;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            if (_args.num1 !== undefined && _args.num2 !== undefined) {
                return new AddInt64Args(_args);
            }
            else {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AddInt64Args from input");
            }
        }
    }
    export interface IAddWithContextArgsArgs {
        num1: number;
        num2: number;
    }
    export class AddWithContextArgs {
        public num1: number;
        public num2: number;
        constructor(args: IAddWithContextArgsArgs) {
            if (args != null && args.num1 != null) {
                this.num1 = args.num1;
            }
            else {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num1] is unset!");
            }
            if (args != null && args.num2 != null) {
                this.num2 = args.num2;
            }
            else {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[num2] is unset!");
            }
        }
        public write(output: thrift.TProtocol): void {
            output.writeStructBegin("AddWithContextArgs");
            if (this.num1 != null) {
                output.writeFieldBegin("num1", thrift.Thrift.Type.I32, 1);
                output.writeI32(this.num1);
                output.writeFieldEnd();
            }
            if (this.num2 != null) {
                output.writeFieldBegin("num2", thrift.Thrift.Type.I32, 2);
                output.writeI32(this.num2);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        }
        public static read(input: thrift.TProtocol): AddWithContextArgs {
            input.readStructBegin();
            let _args: any = {};
            while (true) {
                const ret: thrift.TField = input.readFieldBegin();
                const fieldType: thrift.Thrift.Type = ret.ftype;
                const fieldId: number = ret.fid;
                if (fieldType === thrift.Thrift.Type.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 1:
                        if (fieldType === thrift.Thrift.Type.I32) {
                            const value_13: number = input.readI32();
                            _args.num1 = value_13;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    case 2:
                        if (fieldType === thrift.Thrift.Type.I32) {
                            const value_14: number = input.readI32();
                            _args.num2 = value_14;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            if (_args.num1 !== undefined && _args.num2 !== undefined) {
                return new AddWithContextArgs(_args);
            }
            else {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read AddWithContextArgs from input");
            }
        }
    }
    export interface ICalculateArgsArgs {
        logid: number;
        work: Work;
    }
    export class CalculateArgs {
        public logid: number;
        public work: Work;
        constructor(args: ICalculateArgsArgs) {
            if (args != null && args.logid != null) {
                this.logid = args.logid;
            }
            else {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[logid] is unset!");
            }
            if (args != null && args.work != null) {
                this.work = args.work;
            }
            else {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[work] is unset!");
            }
        }
        public write(output: thrift.TProtocol): void {
            output.writeStructBegin("CalculateArgs");
            if (this.logid != null) {
                output.writeFieldBegin("logid", thrift.Thrift.Type.I32, 1);
                output.writeI32(this.logid);
                output.writeFieldEnd();
            }
            if (this.work != null) {
                output.writeFieldBegin("work", thrift.Thrift.Type.STRUCT, 2);
                this.work.write(output);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        }
        public static read(input: thrift.TProtocol): CalculateArgs {
            input.readStructBegin();
            let _args: any = {};
            while (true) {
                const ret: thrift.TField = input.readFieldBegin();
                const fieldType: thrift.Thrift.Type = ret.ftype;
                const fieldId: number = ret.fid;
                if (fieldType === thrift.Thrift.Type.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 1:
                        if (fieldType === thrift.Thrift.Type.I32) {
                            const value_15: number = input.readI32();
                            _args.logid = value_15;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    case 2:
                        if (fieldType === thrift.Thrift.Type.STRUCT) {
                            const value_16: Work = Work.read(input);
                            _args.work = value_16;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            if (_args.logid !== undefined && _args.work !== undefined) {
                return new CalculateArgs(_args);
            }
            else {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CalculateArgs from input");
            }
        }
    }
    export interface IEchoBinaryArgsArgs {
        word: Buffer;
    }
    export class EchoBinaryArgs {
        public word: Buffer;
        constructor(args: IEchoBinaryArgsArgs) {
            if (args != null && args.word != null) {
                this.word = args.word;
            }
            else {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[word] is unset!");
            }
        }
        public write(output: thrift.TProtocol): void {
            output.writeStructBegin("EchoBinaryArgs");
            if (this.word != null) {
                output.writeFieldBegin("word", thrift.Thrift.Type.STRING, 1);
                output.writeBinary(this.word);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        }
        public static read(input: thrift.TProtocol): EchoBinaryArgs {
            input.readStructBegin();
            let _args: any = {};
            while (true) {
                const ret: thrift.TField = input.readFieldBegin();
                const fieldType: thrift.Thrift.Type = ret.ftype;
                const fieldId: number = ret.fid;
                if (fieldType === thrift.Thrift.Type.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 1:
                        if (fieldType === thrift.Thrift.Type.STRING) {
                            const value_17: Buffer = input.readBinary();
                            _args.word = value_17;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            if (_args.word !== undefined) {
                return new EchoBinaryArgs(_args);
            }
            else {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read EchoBinaryArgs from input");
            }
        }
    }
    export interface IEchoStringArgsArgs {
        word: string;
    }
    export class EchoStringArgs {
        public word: string;
        constructor(args: IEchoStringArgsArgs) {
            if (args != null && args.word != null) {
                this.word = args.word;
            }
            else {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[word] is unset!");
            }
        }
        public write(output: thrift.TProtocol): void {
            output.writeStructBegin("EchoStringArgs");
            if (this.word != null) {
                output.writeFieldBegin("word", thrift.Thrift.Type.STRING, 1);
                output.writeString(this.word);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        }
        public static read(input: thrift.TProtocol): EchoStringArgs {
            input.readStructBegin();
            let _args: any = {};
            while (true) {
                const ret: thrift.TField = input.readFieldBegin();
                const fieldType: thrift.Thrift.Type = ret.ftype;
                const fieldId: number = ret.fid;
                if (fieldType === thrift.Thrift.Type.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 1:
                        if (fieldType === thrift.Thrift.Type.STRING) {
                            const value_18: string = input.readString();
                            _args.word = value_18;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            if (_args.word !== undefined) {
                return new EchoStringArgs(_args);
            }
            else {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read EchoStringArgs from input");
            }
        }
    }
    export interface ICheckNameArgsArgs {
        choice: Choice;
    }
    export class CheckNameArgs {
        public choice: Choice;
        constructor(args: ICheckNameArgsArgs) {
            if (args != null && args.choice != null) {
                this.choice = args.choice;
            }
            else {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[choice] is unset!");
            }
        }
        public write(output: thrift.TProtocol): void {
            output.writeStructBegin("CheckNameArgs");
            if (this.choice != null) {
                output.writeFieldBegin("choice", thrift.Thrift.Type.STRUCT, 1);
                this.choice.write(output);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        }
        public static read(input: thrift.TProtocol): CheckNameArgs {
            input.readStructBegin();
            let _args: any = {};
            while (true) {
                const ret: thrift.TField = input.readFieldBegin();
                const fieldType: thrift.Thrift.Type = ret.ftype;
                const fieldId: number = ret.fid;
                if (fieldType === thrift.Thrift.Type.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 1:
                        if (fieldType === thrift.Thrift.Type.STRUCT) {
                            const value_19: Choice = Choice.read(input);
                            _args.choice = value_19;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            if (_args.choice !== undefined) {
                return new CheckNameArgs(_args);
            }
            else {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read CheckNameArgs from input");
            }
        }
    }
    export interface ICheckOptionalArgsArgs {
        type?: string;
    }
    export class CheckOptionalArgs {
        public type?: string;
        constructor(args?: ICheckOptionalArgsArgs) {
            if (args != null && args.type != null) {
                this.type = args.type;
            }
        }
        public write(output: thrift.TProtocol): void {
            output.writeStructBegin("CheckOptionalArgs");
            if (this.type != null) {
                output.writeFieldBegin("type", thrift.Thrift.Type.STRING, 1);
                output.writeString(this.type);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        }
        public static read(input: thrift.TProtocol): CheckOptionalArgs {
            input.readStructBegin();
            let _args: any = {};
            while (true) {
                const ret: thrift.TField = input.readFieldBegin();
                const fieldType: thrift.Thrift.Type = ret.ftype;
                const fieldId: number = ret.fid;
                if (fieldType === thrift.Thrift.Type.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 1:
                        if (fieldType === thrift.Thrift.Type.STRING) {
                            const value_20: string = input.readString();
                            _args.type = value_20;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return new CheckOptionalArgs(_args);
        }
    }
    export interface IMapOneListArgsArgs {
        arg: Array<number>;
    }
    export class MapOneListArgs {
        public arg: Array<number>;
        constructor(args: IMapOneListArgsArgs) {
            if (args != null && args.arg != null) {
                this.arg = args.arg;
            }
            else {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[arg] is unset!");
            }
        }
        public write(output: thrift.TProtocol): void {
            output.writeStructBegin("MapOneListArgs");
            if (this.arg != null) {
                output.writeFieldBegin("arg", thrift.Thrift.Type.LIST, 1);
                output.writeListBegin(thrift.Thrift.Type.I32, this.arg.length);
                this.arg.forEach((value_21: number): void => {
                    output.writeI32(value_21);
                });
                output.writeListEnd();
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        }
        public static read(input: thrift.TProtocol): MapOneListArgs {
            input.readStructBegin();
            let _args: any = {};
            while (true) {
                const ret: thrift.TField = input.readFieldBegin();
                const fieldType: thrift.Thrift.Type = ret.ftype;
                const fieldId: number = ret.fid;
                if (fieldType === thrift.Thrift.Type.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 1:
                        if (fieldType === thrift.Thrift.Type.LIST) {
                            const value_22: Array<number> = new Array<number>();
                            const metadata_1: thrift.TList = input.readListBegin();
                            const size_1: number = metadata_1.size;
                            for (let i_1: number = 0; i_1 < size_1; i_1++) {
                                const value_23: number = input.readI32();
                                value_22.push(value_23);
                            }
                            input.readListEnd();
                            _args.arg = value_22;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            if (_args.arg !== undefined) {
                return new MapOneListArgs(_args);
            }
            else {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read MapOneListArgs from input");
            }
        }
    }
    export interface IMapValuesArgsArgs {
        arg: Map<string, number>;
    }
    export class MapValuesArgs {
        public arg: Map<string, number>;
        constructor(args: IMapValuesArgsArgs) {
            if (args != null && args.arg != null) {
                this.arg = args.arg;
            }
            else {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[arg] is unset!");
            }
        }
        public write(output: thrift.TProtocol): void {
            output.writeStructBegin("MapValuesArgs");
            if (this.arg != null) {
                output.writeFieldBegin("arg", thrift.Thrift.Type.MAP, 1);
                output.writeMapBegin(thrift.Thrift.Type.STRING, thrift.Thrift.Type.I32, this.arg.size);
                this.arg.forEach((value_24: number, key_1: string): void => {
                    output.writeString(key_1);
                    output.writeI32(value_24);
                });
                output.writeMapEnd();
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        }
        public static read(input: thrift.TProtocol): MapValuesArgs {
            input.readStructBegin();
            let _args: any = {};
            while (true) {
                const ret: thrift.TField = input.readFieldBegin();
                const fieldType: thrift.Thrift.Type = ret.ftype;
                const fieldId: number = ret.fid;
                if (fieldType === thrift.Thrift.Type.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 1:
                        if (fieldType === thrift.Thrift.Type.MAP) {
                            const value_25: Map<string, number> = new Map<string, number>();
                            const metadata_2: thrift.TMap = input.readMapBegin();
                            const size_2: number = metadata_2.size;
                            for (let i_2: number = 0; i_2 < size_2; i_2++) {
                                const key_2: string = input.readString();
                                const value_26: number = input.readI32();
                                value_25.set(key_2, value_26);
                            }
                            input.readMapEnd();
                            _args.arg = value_25;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            if (_args.arg !== undefined) {
                return new MapValuesArgs(_args);
            }
            else {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read MapValuesArgs from input");
            }
        }
    }
    export interface IListToMapArgsArgs {
        arg: Array<Array<string>>;
    }
    export class ListToMapArgs {
        public arg: Array<Array<string>>;
        constructor(args: IListToMapArgsArgs) {
            if (args != null && args.arg != null) {
                this.arg = args.arg;
            }
            else {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Required field[arg] is unset!");
            }
        }
        public write(output: thrift.TProtocol): void {
            output.writeStructBegin("ListToMapArgs");
            if (this.arg != null) {
                output.writeFieldBegin("arg", thrift.Thrift.Type.LIST, 1);
                output.writeListBegin(thrift.Thrift.Type.LIST, this.arg.length);
                this.arg.forEach((value_27: Array<string>): void => {
                    output.writeListBegin(thrift.Thrift.Type.STRING, value_27.length);
                    value_27.forEach((value_28: string): void => {
                        output.writeString(value_28);
                    });
                    output.writeListEnd();
                });
                output.writeListEnd();
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        }
        public static read(input: thrift.TProtocol): ListToMapArgs {
            input.readStructBegin();
            let _args: any = {};
            while (true) {
                const ret: thrift.TField = input.readFieldBegin();
                const fieldType: thrift.Thrift.Type = ret.ftype;
                const fieldId: number = ret.fid;
                if (fieldType === thrift.Thrift.Type.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 1:
                        if (fieldType === thrift.Thrift.Type.LIST) {
                            const value_29: Array<Array<string>> = new Array<Array<string>>();
                            const metadata_3: thrift.TList = input.readListBegin();
                            const size_3: number = metadata_3.size;
                            for (let i_3: number = 0; i_3 < size_3; i_3++) {
                                const value_30: Array<string> = new Array<string>();
                                const metadata_4: thrift.TList = input.readListBegin();
                                const size_4: number = metadata_4.size;
                                for (let i_4: number = 0; i_4 < size_4; i_4++) {
                                    const value_31: string = input.readString();
                                    value_30.push(value_31);
                                }
                                input.readListEnd();
                                value_29.push(value_30);
                            }
                            input.readListEnd();
                            _args.arg = value_29;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            if (_args.arg !== undefined) {
                return new ListToMapArgs(_args);
            }
            else {
                throw new thrift.Thrift.TProtocolException(thrift.Thrift.TProtocolExceptionType.UNKNOWN, "Unable to read ListToMapArgs from input");
            }
        }
    }
    export interface IFetchThingArgsArgs {
    }
    export class FetchThingArgs {
        constructor() {
        }
        public write(output: thrift.TProtocol): void {
            output.writeStructBegin("FetchThingArgs");
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        }
        public static read(input: thrift.TProtocol): FetchThingArgs {
            input.readStructBegin();
            while (true) {
                const ret: thrift.TField = input.readFieldBegin();
                const fieldType: thrift.Thrift.Type = ret.ftype;
                const fieldId: number = ret.fid;
                if (fieldType === thrift.Thrift.Type.STOP) {
                    break;
                }
                switch (fieldId) {
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return new FetchThingArgs();
        }
    }
    export interface IZipArgsArgs {
    }
    export class ZipArgs {
        constructor() {
        }
        public write(output: thrift.TProtocol): void {
            output.writeStructBegin("ZipArgs");
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        }
        public static read(input: thrift.TProtocol): ZipArgs {
            input.readStructBegin();
            while (true) {
                const ret: thrift.TField = input.readFieldBegin();
                const fieldType: thrift.Thrift.Type = ret.ftype;
                const fieldId: number = ret.fid;
                if (fieldType === thrift.Thrift.Type.STOP) {
                    break;
                }
                switch (fieldId) {
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return new ZipArgs();
        }
    }
    export interface IPingResultArgs {
        success?: void;
    }
    export class PingResult {
        public success?: void;
        constructor(args?: IPingResultArgs) {
            if (args != null && args.success != null) {
                this.success = args.success;
            }
        }
        public write(output: thrift.TProtocol): void {
            output.writeStructBegin("PingResult");
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        }
        public static read(input: thrift.TProtocol): PingResult {
            input.readStructBegin();
            let _args: any = {};
            while (true) {
                const ret: thrift.TField = input.readFieldBegin();
                const fieldType: thrift.Thrift.Type = ret.ftype;
                const fieldId: number = ret.fid;
                if (fieldType === thrift.Thrift.Type.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.Thrift.Type.VOID) {
                            input.skip(fieldType);
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return new PingResult(_args);
        }
    }
    export interface IAddResultArgs {
        success?: number;
        exp?: operation.JankyResult;
    }
    export class AddResult {
        public success?: number;
        public exp?: operation.JankyResult;
        constructor(args?: IAddResultArgs) {
            if (args != null && args.success != null) {
                this.success = args.success;
            }
            if (args != null && args.exp != null) {
                this.exp = args.exp;
            }
        }
        public write(output: thrift.TProtocol): void {
            output.writeStructBegin("AddResult");
            if (this.success != null) {
                output.writeFieldBegin("success", thrift.Thrift.Type.I32, 0);
                output.writeI32(this.success);
                output.writeFieldEnd();
            }
            if (this.exp != null) {
                output.writeFieldBegin("exp", thrift.Thrift.Type.STRUCT, 1);
                this.exp.write(output);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        }
        public static read(input: thrift.TProtocol): AddResult {
            input.readStructBegin();
            let _args: any = {};
            while (true) {
                const ret: thrift.TField = input.readFieldBegin();
                const fieldType: thrift.Thrift.Type = ret.ftype;
                const fieldId: number = ret.fid;
                if (fieldType === thrift.Thrift.Type.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.Thrift.Type.I32) {
                            const value_32: number = input.readI32();
                            _args.success = value_32;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    case 1:
                        if (fieldType === thrift.Thrift.Type.STRUCT) {
                            const value_33: operation.JankyResult = operation.JankyResult.read(input);
                            _args.exp = value_33;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return new AddResult(_args);
        }
    }
    export interface IAddInt64ResultArgs {
        success?: number | Int64;
    }
    export class AddInt64Result {
        public success?: Int64;
        constructor(args?: IAddInt64ResultArgs) {
            if (args != null && args.success != null) {
                if (typeof args.success === "number") {
                    this.success = new Int64(args.success);
                }
                else {
                    this.success = args.success;
                }
            }
        }
        public write(output: thrift.TProtocol): void {
            output.writeStructBegin("AddInt64Result");
            if (this.success != null) {
                output.writeFieldBegin("success", thrift.Thrift.Type.I64, 0);
                output.writeI64(this.success);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        }
        public static read(input: thrift.TProtocol): AddInt64Result {
            input.readStructBegin();
            let _args: any = {};
            while (true) {
                const ret: thrift.TField = input.readFieldBegin();
                const fieldType: thrift.Thrift.Type = ret.ftype;
                const fieldId: number = ret.fid;
                if (fieldType === thrift.Thrift.Type.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.Thrift.Type.I64) {
                            const value_34: Int64 = input.readI64();
                            _args.success = value_34;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return new AddInt64Result(_args);
        }
    }
    export interface IAddWithContextResultArgs {
        success?: number;
    }
    export class AddWithContextResult {
        public success?: number;
        constructor(args?: IAddWithContextResultArgs) {
            if (args != null && args.success != null) {
                this.success = args.success;
            }
        }
        public write(output: thrift.TProtocol): void {
            output.writeStructBegin("AddWithContextResult");
            if (this.success != null) {
                output.writeFieldBegin("success", thrift.Thrift.Type.I32, 0);
                output.writeI32(this.success);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        }
        public static read(input: thrift.TProtocol): AddWithContextResult {
            input.readStructBegin();
            let _args: any = {};
            while (true) {
                const ret: thrift.TField = input.readFieldBegin();
                const fieldType: thrift.Thrift.Type = ret.ftype;
                const fieldId: number = ret.fid;
                if (fieldType === thrift.Thrift.Type.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.Thrift.Type.I32) {
                            const value_35: number = input.readI32();
                            _args.success = value_35;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return new AddWithContextResult(_args);
        }
    }
    export interface ICalculateResultArgs {
        success?: number;
        ouch?: operation.JankyOperation;
    }
    export class CalculateResult {
        public success?: number;
        public ouch?: operation.JankyOperation;
        constructor(args?: ICalculateResultArgs) {
            if (args != null && args.success != null) {
                this.success = args.success;
            }
            if (args != null && args.ouch != null) {
                this.ouch = args.ouch;
            }
        }
        public write(output: thrift.TProtocol): void {
            output.writeStructBegin("CalculateResult");
            if (this.success != null) {
                output.writeFieldBegin("success", thrift.Thrift.Type.I32, 0);
                output.writeI32(this.success);
                output.writeFieldEnd();
            }
            if (this.ouch != null) {
                output.writeFieldBegin("ouch", thrift.Thrift.Type.STRUCT, 1);
                this.ouch.write(output);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        }
        public static read(input: thrift.TProtocol): CalculateResult {
            input.readStructBegin();
            let _args: any = {};
            while (true) {
                const ret: thrift.TField = input.readFieldBegin();
                const fieldType: thrift.Thrift.Type = ret.ftype;
                const fieldId: number = ret.fid;
                if (fieldType === thrift.Thrift.Type.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.Thrift.Type.I32) {
                            const value_36: number = input.readI32();
                            _args.success = value_36;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    case 1:
                        if (fieldType === thrift.Thrift.Type.STRUCT) {
                            const value_37: operation.JankyOperation = operation.JankyOperation.read(input);
                            _args.ouch = value_37;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return new CalculateResult(_args);
        }
    }
    export interface IEchoBinaryResultArgs {
        success?: string;
    }
    export class EchoBinaryResult {
        public success?: string;
        constructor(args?: IEchoBinaryResultArgs) {
            if (args != null && args.success != null) {
                this.success = args.success;
            }
        }
        public write(output: thrift.TProtocol): void {
            output.writeStructBegin("EchoBinaryResult");
            if (this.success != null) {
                output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
                output.writeString(this.success);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        }
        public static read(input: thrift.TProtocol): EchoBinaryResult {
            input.readStructBegin();
            let _args: any = {};
            while (true) {
                const ret: thrift.TField = input.readFieldBegin();
                const fieldType: thrift.Thrift.Type = ret.ftype;
                const fieldId: number = ret.fid;
                if (fieldType === thrift.Thrift.Type.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.Thrift.Type.STRING) {
                            const value_38: string = input.readString();
                            _args.success = value_38;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return new EchoBinaryResult(_args);
        }
    }
    export interface IEchoStringResultArgs {
        success?: string;
    }
    export class EchoStringResult {
        public success?: string;
        constructor(args?: IEchoStringResultArgs) {
            if (args != null && args.success != null) {
                this.success = args.success;
            }
        }
        public write(output: thrift.TProtocol): void {
            output.writeStructBegin("EchoStringResult");
            if (this.success != null) {
                output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
                output.writeString(this.success);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        }
        public static read(input: thrift.TProtocol): EchoStringResult {
            input.readStructBegin();
            let _args: any = {};
            while (true) {
                const ret: thrift.TField = input.readFieldBegin();
                const fieldType: thrift.Thrift.Type = ret.ftype;
                const fieldId: number = ret.fid;
                if (fieldType === thrift.Thrift.Type.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.Thrift.Type.STRING) {
                            const value_39: string = input.readString();
                            _args.success = value_39;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return new EchoStringResult(_args);
        }
    }
    export interface ICheckNameResultArgs {
        success?: string;
    }
    export class CheckNameResult {
        public success?: string;
        constructor(args?: ICheckNameResultArgs) {
            if (args != null && args.success != null) {
                this.success = args.success;
            }
        }
        public write(output: thrift.TProtocol): void {
            output.writeStructBegin("CheckNameResult");
            if (this.success != null) {
                output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
                output.writeString(this.success);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        }
        public static read(input: thrift.TProtocol): CheckNameResult {
            input.readStructBegin();
            let _args: any = {};
            while (true) {
                const ret: thrift.TField = input.readFieldBegin();
                const fieldType: thrift.Thrift.Type = ret.ftype;
                const fieldId: number = ret.fid;
                if (fieldType === thrift.Thrift.Type.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.Thrift.Type.STRING) {
                            const value_40: string = input.readString();
                            _args.success = value_40;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return new CheckNameResult(_args);
        }
    }
    export interface ICheckOptionalResultArgs {
        success?: string;
    }
    export class CheckOptionalResult {
        public success?: string;
        constructor(args?: ICheckOptionalResultArgs) {
            if (args != null && args.success != null) {
                this.success = args.success;
            }
        }
        public write(output: thrift.TProtocol): void {
            output.writeStructBegin("CheckOptionalResult");
            if (this.success != null) {
                output.writeFieldBegin("success", thrift.Thrift.Type.STRING, 0);
                output.writeString(this.success);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        }
        public static read(input: thrift.TProtocol): CheckOptionalResult {
            input.readStructBegin();
            let _args: any = {};
            while (true) {
                const ret: thrift.TField = input.readFieldBegin();
                const fieldType: thrift.Thrift.Type = ret.ftype;
                const fieldId: number = ret.fid;
                if (fieldType === thrift.Thrift.Type.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.Thrift.Type.STRING) {
                            const value_41: string = input.readString();
                            _args.success = value_41;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return new CheckOptionalResult(_args);
        }
    }
    export interface IMapOneListResultArgs {
        success?: Array<number>;
    }
    export class MapOneListResult {
        public success?: Array<number>;
        constructor(args?: IMapOneListResultArgs) {
            if (args != null && args.success != null) {
                this.success = args.success;
            }
        }
        public write(output: thrift.TProtocol): void {
            output.writeStructBegin("MapOneListResult");
            if (this.success != null) {
                output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
                output.writeListBegin(thrift.Thrift.Type.I32, this.success.length);
                this.success.forEach((value_42: number): void => {
                    output.writeI32(value_42);
                });
                output.writeListEnd();
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        }
        public static read(input: thrift.TProtocol): MapOneListResult {
            input.readStructBegin();
            let _args: any = {};
            while (true) {
                const ret: thrift.TField = input.readFieldBegin();
                const fieldType: thrift.Thrift.Type = ret.ftype;
                const fieldId: number = ret.fid;
                if (fieldType === thrift.Thrift.Type.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.Thrift.Type.LIST) {
                            const value_43: Array<number> = new Array<number>();
                            const metadata_5: thrift.TList = input.readListBegin();
                            const size_5: number = metadata_5.size;
                            for (let i_5: number = 0; i_5 < size_5; i_5++) {
                                const value_44: number = input.readI32();
                                value_43.push(value_44);
                            }
                            input.readListEnd();
                            _args.success = value_43;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return new MapOneListResult(_args);
        }
    }
    export interface IMapValuesResultArgs {
        success?: Array<number>;
    }
    export class MapValuesResult {
        public success?: Array<number>;
        constructor(args?: IMapValuesResultArgs) {
            if (args != null && args.success != null) {
                this.success = args.success;
            }
        }
        public write(output: thrift.TProtocol): void {
            output.writeStructBegin("MapValuesResult");
            if (this.success != null) {
                output.writeFieldBegin("success", thrift.Thrift.Type.LIST, 0);
                output.writeListBegin(thrift.Thrift.Type.I32, this.success.length);
                this.success.forEach((value_45: number): void => {
                    output.writeI32(value_45);
                });
                output.writeListEnd();
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        }
        public static read(input: thrift.TProtocol): MapValuesResult {
            input.readStructBegin();
            let _args: any = {};
            while (true) {
                const ret: thrift.TField = input.readFieldBegin();
                const fieldType: thrift.Thrift.Type = ret.ftype;
                const fieldId: number = ret.fid;
                if (fieldType === thrift.Thrift.Type.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.Thrift.Type.LIST) {
                            const value_46: Array<number> = new Array<number>();
                            const metadata_6: thrift.TList = input.readListBegin();
                            const size_6: number = metadata_6.size;
                            for (let i_6: number = 0; i_6 < size_6; i_6++) {
                                const value_47: number = input.readI32();
                                value_46.push(value_47);
                            }
                            input.readListEnd();
                            _args.success = value_46;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return new MapValuesResult(_args);
        }
    }
    export interface IListToMapResultArgs {
        success?: Map<string, string>;
    }
    export class ListToMapResult {
        public success?: Map<string, string>;
        constructor(args?: IListToMapResultArgs) {
            if (args != null && args.success != null) {
                this.success = args.success;
            }
        }
        public write(output: thrift.TProtocol): void {
            output.writeStructBegin("ListToMapResult");
            if (this.success != null) {
                output.writeFieldBegin("success", thrift.Thrift.Type.MAP, 0);
                output.writeMapBegin(thrift.Thrift.Type.STRING, thrift.Thrift.Type.STRING, this.success.size);
                this.success.forEach((value_48: string, key_3: string): void => {
                    output.writeString(key_3);
                    output.writeString(value_48);
                });
                output.writeMapEnd();
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        }
        public static read(input: thrift.TProtocol): ListToMapResult {
            input.readStructBegin();
            let _args: any = {};
            while (true) {
                const ret: thrift.TField = input.readFieldBegin();
                const fieldType: thrift.Thrift.Type = ret.ftype;
                const fieldId: number = ret.fid;
                if (fieldType === thrift.Thrift.Type.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.Thrift.Type.MAP) {
                            const value_49: Map<string, string> = new Map<string, string>();
                            const metadata_7: thrift.TMap = input.readMapBegin();
                            const size_7: number = metadata_7.size;
                            for (let i_7: number = 0; i_7 < size_7; i_7++) {
                                const key_4: string = input.readString();
                                const value_50: string = input.readString();
                                value_49.set(key_4, value_50);
                            }
                            input.readMapEnd();
                            _args.success = value_49;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return new ListToMapResult(_args);
        }
    }
    export interface IFetchThingResultArgs {
        success?: common.CommonStruct;
    }
    export class FetchThingResult {
        public success?: common.CommonStruct;
        constructor(args?: IFetchThingResultArgs) {
            if (args != null && args.success != null) {
                this.success = args.success;
            }
        }
        public write(output: thrift.TProtocol): void {
            output.writeStructBegin("FetchThingResult");
            if (this.success != null) {
                output.writeFieldBegin("success", thrift.Thrift.Type.STRUCT, 0);
                this.success.write(output);
                output.writeFieldEnd();
            }
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        }
        public static read(input: thrift.TProtocol): FetchThingResult {
            input.readStructBegin();
            let _args: any = {};
            while (true) {
                const ret: thrift.TField = input.readFieldBegin();
                const fieldType: thrift.Thrift.Type = ret.ftype;
                const fieldId: number = ret.fid;
                if (fieldType === thrift.Thrift.Type.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.Thrift.Type.STRUCT) {
                            const value_51: common.CommonStruct = common.CommonStruct.read(input);
                            _args.success = value_51;
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return new FetchThingResult(_args);
        }
    }
    export interface IZipResultArgs {
        success?: void;
    }
    export class ZipResult {
        public success?: void;
        constructor(args?: IZipResultArgs) {
            if (args != null && args.success != null) {
                this.success = args.success;
            }
        }
        public write(output: thrift.TProtocol): void {
            output.writeStructBegin("ZipResult");
            output.writeFieldStop();
            output.writeStructEnd();
            return;
        }
        public static read(input: thrift.TProtocol): ZipResult {
            input.readStructBegin();
            let _args: any = {};
            while (true) {
                const ret: thrift.TField = input.readFieldBegin();
                const fieldType: thrift.Thrift.Type = ret.ftype;
                const fieldId: number = ret.fid;
                if (fieldType === thrift.Thrift.Type.STOP) {
                    break;
                }
                switch (fieldId) {
                    case 0:
                        if (fieldType === thrift.Thrift.Type.VOID) {
                            input.skip(fieldType);
                        }
                        else {
                            input.skip(fieldType);
                        }
                        break;
                    default: {
                        input.skip(fieldType);
                    }
                }
                input.readFieldEnd();
            }
            input.readStructEnd();
            return new ZipResult(_args);
        }
    }
    export class Client extends shared.SharedService.Client {
        public _seqid: number;
        public _reqs: {
            [name: number]: (err: Error | object | undefined, val?: any) => void;
        };
        public output: thrift.TTransport;
        public protocol: new (trans: thrift.TTransport) => thrift.TProtocol;
        constructor(output: thrift.TTransport, protocol: new (trans: thrift.TTransport) => thrift.TProtocol) {
            super(output, protocol);
            this._seqid = 0;
            this._reqs = {};
            this.output = output;
            this.protocol = protocol;
        }
        public incrementSeqId(): number {
            return this._seqid += 1;
        }
        public ping(): Promise<void> {
            const requestId: number = this.incrementSeqId();
            return new Promise<void>((resolve, reject): void => {
                this._reqs[requestId] = (error, result) => {
                    delete this._reqs[requestId];
                    if (error != null) {
                        reject(error);
                    }
                    else {
                        resolve(result);
                    }
                };
                this.send_ping(requestId);
            });
        }
        public add(num1: number, num2: number): Promise<number> {
            const requestId: number = this.incrementSeqId();
            return new Promise<number>((resolve, reject): void => {
                this._reqs[requestId] = (error, result) => {
                    delete this._reqs[requestId];
                    if (error != null) {
                        reject(error);
                    }
                    else {
                        resolve(result);
                    }
                };
                this.send_add(num1, num2, requestId);
            });
        }
        public addInt64(num1: Int64, num2: Int64): Promise<Int64> {
            const requestId: number = this.incrementSeqId();
            return new Promise<Int64>((resolve, reject): void => {
                this._reqs[requestId] = (error, result) => {
                    delete this._reqs[requestId];
                    if (error != null) {
                        reject(error);
                    }
                    else {
                        resolve(result);
                    }
                };
                this.send_addInt64(num1, num2, requestId);
            });
        }
        public addWithContext(num1: number, num2: number): Promise<number> {
            const requestId: number = this.incrementSeqId();
            return new Promise<number>((resolve, reject): void => {
                this._reqs[requestId] = (error, result) => {
                    delete this._reqs[requestId];
                    if (error != null) {
                        reject(error);
                    }
                    else {
                        resolve(result);
                    }
                };
                this.send_addWithContext(num1, num2, requestId);
            });
        }
        public calculate(logid: number, work: Work): Promise<number> {
            const requestId: number = this.incrementSeqId();
            return new Promise<number>((resolve, reject): void => {
                this._reqs[requestId] = (error, result) => {
                    delete this._reqs[requestId];
                    if (error != null) {
                        reject(error);
                    }
                    else {
                        resolve(result);
                    }
                };
                this.send_calculate(logid, work, requestId);
            });
        }
        public echoBinary(word: Buffer): Promise<string> {
            const requestId: number = this.incrementSeqId();
            return new Promise<string>((resolve, reject): void => {
                this._reqs[requestId] = (error, result) => {
                    delete this._reqs[requestId];
                    if (error != null) {
                        reject(error);
                    }
                    else {
                        resolve(result);
                    }
                };
                this.send_echoBinary(word, requestId);
            });
        }
        public echoString(word: string): Promise<string> {
            const requestId: number = this.incrementSeqId();
            return new Promise<string>((resolve, reject): void => {
                this._reqs[requestId] = (error, result) => {
                    delete this._reqs[requestId];
                    if (error != null) {
                        reject(error);
                    }
                    else {
                        resolve(result);
                    }
                };
                this.send_echoString(word, requestId);
            });
        }
        public checkName(choice: Choice): Promise<string> {
            const requestId: number = this.incrementSeqId();
            return new Promise<string>((resolve, reject): void => {
                this._reqs[requestId] = (error, result) => {
                    delete this._reqs[requestId];
                    if (error != null) {
                        reject(error);
                    }
                    else {
                        resolve(result);
                    }
                };
                this.send_checkName(choice, requestId);
            });
        }
        public checkOptional(type?: string): Promise<string> {
            const requestId: number = this.incrementSeqId();
            return new Promise<string>((resolve, reject): void => {
                this._reqs[requestId] = (error, result) => {
                    delete this._reqs[requestId];
                    if (error != null) {
                        reject(error);
                    }
                    else {
                        resolve(result);
                    }
                };
                this.send_checkOptional(type, requestId);
            });
        }
        public mapOneList(arg: Array<number>): Promise<Array<number>> {
            const requestId: number = this.incrementSeqId();
            return new Promise<Array<number>>((resolve, reject): void => {
                this._reqs[requestId] = (error, result) => {
                    delete this._reqs[requestId];
                    if (error != null) {
                        reject(error);
                    }
                    else {
                        resolve(result);
                    }
                };
                this.send_mapOneList(arg, requestId);
            });
        }
        public mapValues(arg: Map<string, number>): Promise<Array<number>> {
            const requestId: number = this.incrementSeqId();
            return new Promise<Array<number>>((resolve, reject): void => {
                this._reqs[requestId] = (error, result) => {
                    delete this._reqs[requestId];
                    if (error != null) {
                        reject(error);
                    }
                    else {
                        resolve(result);
                    }
                };
                this.send_mapValues(arg, requestId);
            });
        }
        public listToMap(arg: Array<Array<string>>): Promise<Map<string, string>> {
            const requestId: number = this.incrementSeqId();
            return new Promise<Map<string, string>>((resolve, reject): void => {
                this._reqs[requestId] = (error, result) => {
                    delete this._reqs[requestId];
                    if (error != null) {
                        reject(error);
                    }
                    else {
                        resolve(result);
                    }
                };
                this.send_listToMap(arg, requestId);
            });
        }
        public fetchThing(): Promise<common.CommonStruct> {
            const requestId: number = this.incrementSeqId();
            return new Promise<common.CommonStruct>((resolve, reject): void => {
                this._reqs[requestId] = (error, result) => {
                    delete this._reqs[requestId];
                    if (error != null) {
                        reject(error);
                    }
                    else {
                        resolve(result);
                    }
                };
                this.send_fetchThing(requestId);
            });
        }
        public zip(): Promise<void> {
            const requestId: number = this.incrementSeqId();
            return new Promise<void>((resolve, reject): void => {
                this._reqs[requestId] = (error, result) => {
                    delete this._reqs[requestId];
                    if (error != null) {
                        reject(error);
                    }
                    else {
                        resolve(result);
                    }
                };
                this.send_zip(requestId);
            });
        }
        public send_ping(requestId: number): void {
            const output: thrift.TProtocol = new this.protocol(this.output);
            output.writeMessageBegin("ping", thrift.Thrift.MessageType.CALL, requestId);
            const args: PingArgs = new PingArgs();
            args.write(output);
            output.writeMessageEnd();
            this.output.flush();
            return;
        }
        public send_add(num1: number, num2: number, requestId: number): void {
            const output: thrift.TProtocol = new this.protocol(this.output);
            output.writeMessageBegin("add", thrift.Thrift.MessageType.CALL, requestId);
            const args: AddArgs = new AddArgs({ num1, num2 });
            args.write(output);
            output.writeMessageEnd();
            this.output.flush();
            return;
        }
        public send_addInt64(num1: Int64, num2: Int64, requestId: number): void {
            const output: thrift.TProtocol = new this.protocol(this.output);
            output.writeMessageBegin("addInt64", thrift.Thrift.MessageType.CALL, requestId);
            const args: AddInt64Args = new AddInt64Args({ num1, num2 });
            args.write(output);
            output.writeMessageEnd();
            this.output.flush();
            return;
        }
        public send_addWithContext(num1: number, num2: number, requestId: number): void {
            const output: thrift.TProtocol = new this.protocol(this.output);
            output.writeMessageBegin("addWithContext", thrift.Thrift.MessageType.CALL, requestId);
            const args: AddWithContextArgs = new AddWithContextArgs({ num1, num2 });
            args.write(output);
            output.writeMessageEnd();
            this.output.flush();
            return;
        }
        public send_calculate(logid: number, work: Work, requestId: number): void {
            const output: thrift.TProtocol = new this.protocol(this.output);
            output.writeMessageBegin("calculate", thrift.Thrift.MessageType.CALL, requestId);
            const args: CalculateArgs = new CalculateArgs({ logid, work });
            args.write(output);
            output.writeMessageEnd();
            this.output.flush();
            return;
        }
        public send_echoBinary(word: Buffer, requestId: number): void {
            const output: thrift.TProtocol = new this.protocol(this.output);
            output.writeMessageBegin("echoBinary", thrift.Thrift.MessageType.CALL, requestId);
            const args: EchoBinaryArgs = new EchoBinaryArgs({ word });
            args.write(output);
            output.writeMessageEnd();
            this.output.flush();
            return;
        }
        public send_echoString(word: string, requestId: number): void {
            const output: thrift.TProtocol = new this.protocol(this.output);
            output.writeMessageBegin("echoString", thrift.Thrift.MessageType.CALL, requestId);
            const args: EchoStringArgs = new EchoStringArgs({ word });
            args.write(output);
            output.writeMessageEnd();
            this.output.flush();
            return;
        }
        public send_checkName(choice: Choice, requestId: number): void {
            const output: thrift.TProtocol = new this.protocol(this.output);
            output.writeMessageBegin("checkName", thrift.Thrift.MessageType.CALL, requestId);
            const args: CheckNameArgs = new CheckNameArgs({ choice });
            args.write(output);
            output.writeMessageEnd();
            this.output.flush();
            return;
        }
        public send_checkOptional(type: string | undefined, requestId: number): void {
            const output: thrift.TProtocol = new this.protocol(this.output);
            output.writeMessageBegin("checkOptional", thrift.Thrift.MessageType.CALL, requestId);
            const args: CheckOptionalArgs = new CheckOptionalArgs({ type });
            args.write(output);
            output.writeMessageEnd();
            this.output.flush();
            return;
        }
        public send_mapOneList(arg: Array<number>, requestId: number): void {
            const output: thrift.TProtocol = new this.protocol(this.output);
            output.writeMessageBegin("mapOneList", thrift.Thrift.MessageType.CALL, requestId);
            const args: MapOneListArgs = new MapOneListArgs({ arg });
            args.write(output);
            output.writeMessageEnd();
            this.output.flush();
            return;
        }
        public send_mapValues(arg: Map<string, number>, requestId: number): void {
            const output: thrift.TProtocol = new this.protocol(this.output);
            output.writeMessageBegin("mapValues", thrift.Thrift.MessageType.CALL, requestId);
            const args: MapValuesArgs = new MapValuesArgs({ arg });
            args.write(output);
            output.writeMessageEnd();
            this.output.flush();
            return;
        }
        public send_listToMap(arg: Array<Array<string>>, requestId: number): void {
            const output: thrift.TProtocol = new this.protocol(this.output);
            output.writeMessageBegin("listToMap", thrift.Thrift.MessageType.CALL, requestId);
            const args: ListToMapArgs = new ListToMapArgs({ arg });
            args.write(output);
            output.writeMessageEnd();
            this.output.flush();
            return;
        }
        public send_fetchThing(requestId: number): void {
            const output: thrift.TProtocol = new this.protocol(this.output);
            output.writeMessageBegin("fetchThing", thrift.Thrift.MessageType.CALL, requestId);
            const args: FetchThingArgs = new FetchThingArgs();
            args.write(output);
            output.writeMessageEnd();
            this.output.flush();
            return;
        }
        public send_zip(requestId: number): void {
            const output: thrift.TProtocol = new this.protocol(this.output);
            output.writeMessageBegin("zip", thrift.Thrift.MessageType.CALL, requestId);
            const args: ZipArgs = new ZipArgs();
            args.write(output);
            output.writeMessageEnd();
            this.output.flush();
            return;
        }
        public recv_ping(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
            const noop = (): any => null;
            const callback = this._reqs[requestId] || noop;
            if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
                const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
                x.read(input);
                input.readMessageEnd();
                return callback(x);
            }
            else {
                input.readMessageEnd();
                return callback(undefined);
            }
        }
        public recv_add(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
            const noop = (): any => null;
            const callback = this._reqs[requestId] || noop;
            if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
                const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
                x.read(input);
                input.readMessageEnd();
                return callback(x);
            }
            else {
                const result: AddResult = AddResult.read(input);
                input.readMessageEnd();
                if (result.exp != null) {
                    return callback(result.exp);
                }
                else {
                    if (result.success != null) {
                        return callback(undefined, result.success);
                    }
                    else {
                        return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "add failed: unknown result"));
                    }
                }
            }
        }
        public recv_addInt64(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
            const noop = (): any => null;
            const callback = this._reqs[requestId] || noop;
            if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
                const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
                x.read(input);
                input.readMessageEnd();
                return callback(x);
            }
            else {
                const result: AddInt64Result = AddInt64Result.read(input);
                input.readMessageEnd();
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "addInt64 failed: unknown result"));
                }
            }
        }
        public recv_addWithContext(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
            const noop = (): any => null;
            const callback = this._reqs[requestId] || noop;
            if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
                const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
                x.read(input);
                input.readMessageEnd();
                return callback(x);
            }
            else {
                const result: AddWithContextResult = AddWithContextResult.read(input);
                input.readMessageEnd();
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "addWithContext failed: unknown result"));
                }
            }
        }
        public recv_calculate(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
            const noop = (): any => null;
            const callback = this._reqs[requestId] || noop;
            if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
                const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
                x.read(input);
                input.readMessageEnd();
                return callback(x);
            }
            else {
                const result: CalculateResult = CalculateResult.read(input);
                input.readMessageEnd();
                if (result.ouch != null) {
                    return callback(result.ouch);
                }
                else {
                    if (result.success != null) {
                        return callback(undefined, result.success);
                    }
                    else {
                        return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "calculate failed: unknown result"));
                    }
                }
            }
        }
        public recv_echoBinary(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
            const noop = (): any => null;
            const callback = this._reqs[requestId] || noop;
            if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
                const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
                x.read(input);
                input.readMessageEnd();
                return callback(x);
            }
            else {
                const result: EchoBinaryResult = EchoBinaryResult.read(input);
                input.readMessageEnd();
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "echoBinary failed: unknown result"));
                }
            }
        }
        public recv_echoString(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
            const noop = (): any => null;
            const callback = this._reqs[requestId] || noop;
            if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
                const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
                x.read(input);
                input.readMessageEnd();
                return callback(x);
            }
            else {
                const result: EchoStringResult = EchoStringResult.read(input);
                input.readMessageEnd();
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "echoString failed: unknown result"));
                }
            }
        }
        public recv_checkName(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
            const noop = (): any => null;
            const callback = this._reqs[requestId] || noop;
            if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
                const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
                x.read(input);
                input.readMessageEnd();
                return callback(x);
            }
            else {
                const result: CheckNameResult = CheckNameResult.read(input);
                input.readMessageEnd();
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "checkName failed: unknown result"));
                }
            }
        }
        public recv_checkOptional(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
            const noop = (): any => null;
            const callback = this._reqs[requestId] || noop;
            if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
                const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
                x.read(input);
                input.readMessageEnd();
                return callback(x);
            }
            else {
                const result: CheckOptionalResult = CheckOptionalResult.read(input);
                input.readMessageEnd();
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "checkOptional failed: unknown result"));
                }
            }
        }
        public recv_mapOneList(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
            const noop = (): any => null;
            const callback = this._reqs[requestId] || noop;
            if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
                const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
                x.read(input);
                input.readMessageEnd();
                return callback(x);
            }
            else {
                const result: MapOneListResult = MapOneListResult.read(input);
                input.readMessageEnd();
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "mapOneList failed: unknown result"));
                }
            }
        }
        public recv_mapValues(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
            const noop = (): any => null;
            const callback = this._reqs[requestId] || noop;
            if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
                const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
                x.read(input);
                input.readMessageEnd();
                return callback(x);
            }
            else {
                const result: MapValuesResult = MapValuesResult.read(input);
                input.readMessageEnd();
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "mapValues failed: unknown result"));
                }
            }
        }
        public recv_listToMap(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
            const noop = (): any => null;
            const callback = this._reqs[requestId] || noop;
            if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
                const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
                x.read(input);
                input.readMessageEnd();
                return callback(x);
            }
            else {
                const result: ListToMapResult = ListToMapResult.read(input);
                input.readMessageEnd();
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "listToMap failed: unknown result"));
                }
            }
        }
        public recv_fetchThing(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
            const noop = (): any => null;
            const callback = this._reqs[requestId] || noop;
            if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
                const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
                x.read(input);
                input.readMessageEnd();
                return callback(x);
            }
            else {
                const result: FetchThingResult = FetchThingResult.read(input);
                input.readMessageEnd();
                if (result.success != null) {
                    return callback(undefined, result.success);
                }
                else {
                    return callback(new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, "fetchThing failed: unknown result"));
                }
            }
        }
        public recv_zip(input: thrift.TProtocol, mtype: thrift.Thrift.MessageType, requestId: number): void {
            const noop = (): any => null;
            const callback = this._reqs[requestId] || noop;
            if (mtype === thrift.Thrift.MessageType.EXCEPTION) {
                const x: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException();
                x.read(input);
                input.readMessageEnd();
                return callback(x);
            }
            else {
                input.readMessageEnd();
                return callback(undefined);
            }
        }
    }
    export interface ILocalHandler {
        ping(): void | Promise<void>;
        add(num1: number, num2: number): number | Promise<number>;
        addInt64(num1: Int64, num2: Int64): Int64 | Promise<Int64>;
        addWithContext(num1: number, num2: number): number | Promise<number>;
        calculate(logid: number, work: Work): number | Promise<number>;
        echoBinary(word: Buffer): string | Promise<string>;
        echoString(word: string): string | Promise<string>;
        checkName(choice: Choice): string | Promise<string>;
        checkOptional(type?: string): string | Promise<string>;
        mapOneList(arg: Array<number>): Array<number> | Promise<Array<number>>;
        mapValues(arg: Map<string, number>): Array<number> | Promise<Array<number>>;
        listToMap(arg: Array<Array<string>>): Map<string, string> | Promise<Map<string, string>>;
        fetchThing(): common.CommonStruct | Promise<common.CommonStruct>;
        zip(): void | Promise<void>;
    }
    export type IHandler = ILocalHandler & shared.SharedService.IHandler;
    export class Processor extends shared.SharedService.Processor {
        public _handler: IHandler;
        constructor(handler: IHandler) {
            super({
                getStruct: handler.getStruct,
                getUnion: handler.getUnion
            });
            this._handler = handler;
        }
        public process(input: thrift.TProtocol, output: thrift.TProtocol): void {
            const metadata: thrift.TMessage = input.readMessageBegin();
            const fname: string = metadata.fname;
            const requestId: number = metadata.rseqid;
            const methodName: string = "process_" + fname;
            switch (methodName) {
                case "process_getStruct": {
                    this.process_getStruct(requestId, input, output);
                    return;
                }
                case "process_getUnion": {
                    this.process_getUnion(requestId, input, output);
                    return;
                }
                case "process_ping": {
                    this.process_ping(requestId, input, output);
                    return;
                }
                case "process_add": {
                    this.process_add(requestId, input, output);
                    return;
                }
                case "process_addInt64": {
                    this.process_addInt64(requestId, input, output);
                    return;
                }
                case "process_addWithContext": {
                    this.process_addWithContext(requestId, input, output);
                    return;
                }
                case "process_calculate": {
                    this.process_calculate(requestId, input, output);
                    return;
                }
                case "process_echoBinary": {
                    this.process_echoBinary(requestId, input, output);
                    return;
                }
                case "process_echoString": {
                    this.process_echoString(requestId, input, output);
                    return;
                }
                case "process_checkName": {
                    this.process_checkName(requestId, input, output);
                    return;
                }
                case "process_checkOptional": {
                    this.process_checkOptional(requestId, input, output);
                    return;
                }
                case "process_mapOneList": {
                    this.process_mapOneList(requestId, input, output);
                    return;
                }
                case "process_mapValues": {
                    this.process_mapValues(requestId, input, output);
                    return;
                }
                case "process_listToMap": {
                    this.process_listToMap(requestId, input, output);
                    return;
                }
                case "process_fetchThing": {
                    this.process_fetchThing(requestId, input, output);
                    return;
                }
                case "process_zip": {
                    this.process_zip(requestId, input, output);
                    return;
                }
                default: {
                    input.skip(thrift.Thrift.Type.STRUCT);
                    input.readMessageEnd();
                    const errMessage = "Unknown function " + fname;
                    const err = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN_METHOD, errMessage);
                    output.writeMessageBegin(fname, thrift.Thrift.MessageType.EXCEPTION, requestId);
                    err.write(output);
                    output.writeMessageEnd();
                    output.flush();
                    return;
                }
            }
        }
        public process_ping(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
            new Promise<void>((resolve, reject): void => {
                try {
                    input.readMessageEnd();
                    resolve(this._handler.ping());
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: void): void => {
                const result: PingResult = new PingResult({ success: data });
                output.writeMessageBegin("ping", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }).catch((err: Error): void => {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("ping", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            });
        }
        public process_add(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
            new Promise<number>((resolve, reject): void => {
                try {
                    const args: AddArgs = AddArgs.read(input);
                    input.readMessageEnd();
                    resolve(this._handler.add(args.num1, args.num2));
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: number): void => {
                const result: AddResult = new AddResult({ success: data });
                output.writeMessageBegin("add", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }).catch((err: Error): void => {
                if (err instanceof operation.JankyResult) {
                    const result: AddResult = new AddResult({ exp: err });
                    output.writeMessageBegin("add", thrift.Thrift.MessageType.REPLY, requestId);
                    result.write(output);
                    output.writeMessageEnd();
                    output.flush();
                    return;
                }
                else {
                    const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                    output.writeMessageBegin("add", thrift.Thrift.MessageType.EXCEPTION, requestId);
                    result.write(output);
                    output.writeMessageEnd();
                    output.flush();
                    return;
                }
            });
        }
        public process_addInt64(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
            new Promise<Int64>((resolve, reject): void => {
                try {
                    const args: AddInt64Args = AddInt64Args.read(input);
                    input.readMessageEnd();
                    resolve(this._handler.addInt64(args.num1, args.num2));
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: Int64): void => {
                const result: AddInt64Result = new AddInt64Result({ success: data });
                output.writeMessageBegin("addInt64", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }).catch((err: Error): void => {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("addInt64", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            });
        }
        public process_addWithContext(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
            new Promise<number>((resolve, reject): void => {
                try {
                    const args: AddWithContextArgs = AddWithContextArgs.read(input);
                    input.readMessageEnd();
                    resolve(this._handler.addWithContext(args.num1, args.num2));
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: number): void => {
                const result: AddWithContextResult = new AddWithContextResult({ success: data });
                output.writeMessageBegin("addWithContext", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }).catch((err: Error): void => {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("addWithContext", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            });
        }
        public process_calculate(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
            new Promise<number>((resolve, reject): void => {
                try {
                    const args: CalculateArgs = CalculateArgs.read(input);
                    input.readMessageEnd();
                    resolve(this._handler.calculate(args.logid, args.work));
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: number): void => {
                const result: CalculateResult = new CalculateResult({ success: data });
                output.writeMessageBegin("calculate", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }).catch((err: Error): void => {
                if (err instanceof operation.JankyOperation) {
                    const result: CalculateResult = new CalculateResult({ ouch: err });
                    output.writeMessageBegin("calculate", thrift.Thrift.MessageType.REPLY, requestId);
                    result.write(output);
                    output.writeMessageEnd();
                    output.flush();
                    return;
                }
                else {
                    const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                    output.writeMessageBegin("calculate", thrift.Thrift.MessageType.EXCEPTION, requestId);
                    result.write(output);
                    output.writeMessageEnd();
                    output.flush();
                    return;
                }
            });
        }
        public process_echoBinary(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
            new Promise<string>((resolve, reject): void => {
                try {
                    const args: EchoBinaryArgs = EchoBinaryArgs.read(input);
                    input.readMessageEnd();
                    resolve(this._handler.echoBinary(args.word));
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: string): void => {
                const result: EchoBinaryResult = new EchoBinaryResult({ success: data });
                output.writeMessageBegin("echoBinary", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }).catch((err: Error): void => {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("echoBinary", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            });
        }
        public process_echoString(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
            new Promise<string>((resolve, reject): void => {
                try {
                    const args: EchoStringArgs = EchoStringArgs.read(input);
                    input.readMessageEnd();
                    resolve(this._handler.echoString(args.word));
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: string): void => {
                const result: EchoStringResult = new EchoStringResult({ success: data });
                output.writeMessageBegin("echoString", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }).catch((err: Error): void => {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("echoString", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            });
        }
        public process_checkName(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
            new Promise<string>((resolve, reject): void => {
                try {
                    const args: CheckNameArgs = CheckNameArgs.read(input);
                    input.readMessageEnd();
                    resolve(this._handler.checkName(args.choice));
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: string): void => {
                const result: CheckNameResult = new CheckNameResult({ success: data });
                output.writeMessageBegin("checkName", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }).catch((err: Error): void => {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("checkName", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            });
        }
        public process_checkOptional(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
            new Promise<string>((resolve, reject): void => {
                try {
                    const args: CheckOptionalArgs = CheckOptionalArgs.read(input);
                    input.readMessageEnd();
                    resolve(this._handler.checkOptional(args.type));
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: string): void => {
                const result: CheckOptionalResult = new CheckOptionalResult({ success: data });
                output.writeMessageBegin("checkOptional", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }).catch((err: Error): void => {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("checkOptional", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            });
        }
        public process_mapOneList(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
            new Promise<Array<number>>((resolve, reject): void => {
                try {
                    const args: MapOneListArgs = MapOneListArgs.read(input);
                    input.readMessageEnd();
                    resolve(this._handler.mapOneList(args.arg));
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: Array<number>): void => {
                const result: MapOneListResult = new MapOneListResult({ success: data });
                output.writeMessageBegin("mapOneList", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }).catch((err: Error): void => {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("mapOneList", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            });
        }
        public process_mapValues(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
            new Promise<Array<number>>((resolve, reject): void => {
                try {
                    const args: MapValuesArgs = MapValuesArgs.read(input);
                    input.readMessageEnd();
                    resolve(this._handler.mapValues(args.arg));
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: Array<number>): void => {
                const result: MapValuesResult = new MapValuesResult({ success: data });
                output.writeMessageBegin("mapValues", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }).catch((err: Error): void => {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("mapValues", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            });
        }
        public process_listToMap(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
            new Promise<Map<string, string>>((resolve, reject): void => {
                try {
                    const args: ListToMapArgs = ListToMapArgs.read(input);
                    input.readMessageEnd();
                    resolve(this._handler.listToMap(args.arg));
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: Map<string, string>): void => {
                const result: ListToMapResult = new ListToMapResult({ success: data });
                output.writeMessageBegin("listToMap", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }).catch((err: Error): void => {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("listToMap", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            });
        }
        public process_fetchThing(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
            new Promise<common.CommonStruct>((resolve, reject): void => {
                try {
                    input.readMessageEnd();
                    resolve(this._handler.fetchThing());
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: common.CommonStruct): void => {
                const result: FetchThingResult = new FetchThingResult({ success: data });
                output.writeMessageBegin("fetchThing", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }).catch((err: Error): void => {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("fetchThing", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            });
        }
        public process_zip(requestId: number, input: thrift.TProtocol, output: thrift.TProtocol): void {
            new Promise<void>((resolve, reject): void => {
                try {
                    input.readMessageEnd();
                    resolve(this._handler.zip());
                }
                catch (err) {
                    reject(err);
                }
            }).then((data: void): void => {
                const result: ZipResult = new ZipResult({ success: data });
                output.writeMessageBegin("zip", thrift.Thrift.MessageType.REPLY, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            }).catch((err: Error): void => {
                const result: thrift.Thrift.TApplicationException = new thrift.Thrift.TApplicationException(thrift.Thrift.TApplicationExceptionType.UNKNOWN, err.message);
                output.writeMessageBegin("zip", thrift.Thrift.MessageType.EXCEPTION, requestId);
                result.write(output);
                output.writeMessageEnd();
                output.flush();
                return;
            });
        }
    }
}

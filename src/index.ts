import * as ts from 'typescript'
const thriftParser = require('thrift-parser');

import readFile from './filesystem/read-file';

import {
  resolveNamespace
} from './resolve';
import {
  TypedefNode,
  resolveTypedefs,
} from './resolve/typedefs';
import {
  InterfaceNode,
  resolveInterfaces
} from './resolve/interfaces';
import {
  StructNode,
  resolveStructs
} from './resolve/structs';

import { identifiers as _id } from './ast/identifiers';
import { tokens as _tokens } from './ast/tokens';

export function parseFile(fileName: string): Promise<any> {
  return readFile(fileName).then(idl => {
    return thriftParser(idl)
  })
}

interface ResolvedIDL {
  namespace?: string,
  typedefs: TypedefNode[],
  interfaces: InterfaceNode[],
  structs: StructNode[],
}

function generateTypesAST(idl: ResolvedIDL): string {

  let prefaceFile = ts.createSourceFile('preface.ts', '', ts.ScriptTarget.ES5, false, ts.ScriptKind.TS);

  const _thriftImport = ts.createImportClause(undefined, ts.createNamedImports([
    ts.createImportSpecifier(undefined, _id.Thrift)
  ]));
  let _require = ts.createImportDeclaration(undefined, undefined, _thriftImport, ts.createLiteral('thrift'));

  _require = ts.addSyntheticLeadingComment(_require, ts.SyntaxKind.SingleLineCommentTrivia, '', false);
  _require = ts.addSyntheticLeadingComment(_require, ts.SyntaxKind.SingleLineCommentTrivia, ' Autogenerated by thrift-typescript', false);
  _require = ts.addSyntheticLeadingComment(_require, ts.SyntaxKind.SingleLineCommentTrivia, '', false);
  _require = ts.addSyntheticLeadingComment(_require, ts.SyntaxKind.SingleLineCommentTrivia, ' DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING', false);
  _require = ts.addSyntheticLeadingComment(_require, ts.SyntaxKind.SingleLineCommentTrivia, '', true);

  prefaceFile = ts.updateSourceFileNode(prefaceFile, [
    _require
  ]);

  const _types = idl.typedefs.map((typedef) => typedef.toAST());

  const _interfaces = idl.interfaces.map((iface) => iface.toAST());

  const _structs = idl.structs.map((struct) => struct.toAST());

  let bodyFile = ts.createSourceFile('body.ts', '', ts.ScriptTarget.ES5, false, ts.ScriptKind.TS);
  // TODO: filename?
  if (idl.namespace) {

    const namespace = ts.createIdentifier(idl.namespace);

    const _namespaceBlock = ts.createModuleBlock([
      ..._types,
      ..._interfaces,
      ..._structs
    ]);

    const _namespace = ts.createModuleDeclaration(undefined, [_tokens.export], namespace, _namespaceBlock, ts.NodeFlags.Namespace);
    bodyFile = ts.updateSourceFileNode(bodyFile, [
      _namespace
    ]);
  } else {
    bodyFile = ts.updateSourceFileNode(bodyFile, [
      ..._types,
      ..._interfaces,
      ..._structs
    ]);
  }

  const printer = ts.createPrinter();

  return printer.printBundle(ts.createBundle([
    prefaceFile,
    bodyFile
  ]));
}


export async function generateIDLTypes(filename: string): Promise<string> {
  let idl = await parseFile(filename);

  const namespace = resolveNamespace(idl);

  // Non-mutation
  const typedefs = resolveTypedefs(idl);
  // Currently moved to InvalidTypeNode
  // validateTypes(typedefs);

  const interfaces = resolveInterfaces(idl);
  // TODO: validate interfaces

  const structs = resolveStructs(idl);
  // Type errors should be handled by InvalidTypeNode
  // validateStructs(structs);

  const resolved = {
    namespace: namespace,
    typedefs: typedefs,
    interfaces: interfaces,
    structs: structs
  }

  return generateTypesAST(resolved);
}

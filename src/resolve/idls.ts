import {
  addSyntheticLeadingComment,
  createModuleBlock,
  createModuleDeclaration,
  ModuleDeclaration,
  NodeFlags,
  SyntaxKind,
} from 'typescript'

import { ConstNode, resolveConsts } from './consts'
import { EnumNode, resolveEnums } from './enums'
import { ExceptionNode, resolveExceptions } from './exceptions'
import { InterfaceNode, resolveInterfaces } from './interfaces'
import { NamespaceNode, resolveNamespace } from './namespace'
import { resolveStructs, StructNode } from './structs'
import { resolveTypedefs, TypedefNode } from './typedefs'
import { resolveUnions, UnionNode } from './unions'

import { tokens } from '../ast/tokens'

export class IDLNode {
  public filename: string
  public namespace: NamespaceNode
  public typedefs: TypedefNode[]
  public consts: ConstNode[]
  public enums: EnumNode[]
  public interfaces: InterfaceNode[]
  public structs: StructNode[]
  public unions: UnionNode[]
  public exceptions: ExceptionNode[]

  constructor(filename: string, idl: JsonAST) {
    this.filename = filename
    // TODO: are the `resolve` methods better served in the constructor or resolveIDLs?
    this.namespace = resolveNamespace(idl, filename)
    this.typedefs = resolveTypedefs(idl)
    this.consts = resolveConsts(idl)
    this.enums = resolveEnums(idl)
    this.interfaces = resolveInterfaces(idl)
    this.structs = resolveStructs(idl)
    this.unions = resolveUnions(idl)
    this.exceptions = resolveExceptions(idl)
  }

  public toAST(): ModuleDeclaration {
    const namespace = this.namespace.toAST()
    const types = this.typedefs.map((typedef) => typedef.toAST())
    const constants = this.consts.map((constant) => constant.toAST())
    const enums = this.enums.map((enu) => enu.toAST())
    const interfaces = this.interfaces.map((iface) => iface.toAST())
    const structs = this.structs.map((struct) => struct.toAST())
    const unions = this.unions.map((union) => union.toAST())
    const exceptions = this.exceptions.map((exception) => exception.toAST())

    // TODO: Have to investigate ordering here, it might matter
    const namespaceBlock = createModuleBlock([
      ...types,
      ...enums,
      ...interfaces,
      ...structs,
      ...unions,
      ...exceptions,
      ...constants,
    ])

    let moduleDec = createModuleDeclaration(undefined, [tokens.export], namespace, namespaceBlock, NodeFlags.Namespace)

    moduleDec = addSyntheticLeadingComment(moduleDec, SyntaxKind.SingleLineCommentTrivia,
      ` Generated by ${this.filename}`, false)

    return moduleDec
  }
}

// TODO: IDLFile[]
export function resolveIDLs(files: any[]) {
  return files.map((file) => new IDLNode(file.filename, file.idl))
}
